[
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "a810850a-627d-49f6-b488-f30df372fe2f",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC001-user login functionality",
    "description": "Test the user login endpoint to verify successful login with valid credentials, handling of invalid credentials, and enforcement of rate limits.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3003\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_functionality():\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Define valid credentials (these should exist in system for the test)\n    valid_username = \"testuser\"\n    valid_password = \"testpassword123\"\n\n    # 1. Test successful login with valid credentials\n    login_payload = {\n        \"username\": valid_username,\n        \"password\": valid_password\n    }\n    response = requests.post(LOGIN_URL, json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected 200, got {response.status_code}\"\n    response_json = response.json()\n    assert \"token\" in response_json or \"accessToken\" in response_json, \"JWT token not returned on successful login\"\n\n    # 2. Test login with invalid credentials - invalid password\n    invalid_payload = {\n        \"username\": valid_username,\n        \"password\": \"wrongpassword\"\n    }\n    response_invalid = requests.post(LOGIN_URL, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n    assert response_invalid.status_code == 401, f\"Expected 401 Unauthorized for invalid password, got {response_invalid.status_code}\"\n\n    # 3. Test rate limiting enforcement\n    # Make multiple rapid requests with invalid credentials to trigger rate limiting\n    max_attempts = 10  # Reasonable high attempts to trigger rate limit\n    rate_limited = False\n    for _ in range(max_attempts):\n        resp = requests.post(LOGIN_URL, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        if resp.status_code == 429:\n            rate_limited = True\n            break\n        # Slight delay to not immediately hammer server too fast\n        time.sleep(0.1)\n\n    assert rate_limited, \"Rate limit not enforced after multiple invalid login attempts\"\n\ntest_user_login_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 47, in <module>\n  File \"<string>\", line 21, in test_user_login_functionality\nAssertionError: Expected 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.431Z",
    "modified": "2025-12-15T20:04:22.190Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "35eba87c-183d-4e84-89dc-e767d6ffd1b0",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC002-user registration process",
    "description": "Validate the user registration endpoint for successful registration with required fields, and proper handling of validation errors.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nREGISTER_ENDPOINT = \"/api/auth/register\"\nTIMEOUT = 30\n\ndef test_user_registration_process():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Test data for successful registration\n    valid_payload = {\n        \"username\": \"testuser_tc002\",\n        \"email\": \"testuser_tc002@example.com\",\n        \"password\": \"StrongPass!123\"\n    }\n\n    # 1) Test successful registration\n    response = requests.post(\n        url=f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n        json=valid_payload,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    try:\n        assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n    except AssertionError:\n        # If registration fails because user exists, ignore for test purpose as no cleanup specified\n        if response.status_code == 400 and \"already\" in response.text.lower():\n            # This means user already exists, treat as pass for this success test since it shows validation works\n            pass\n        else:\n            raise\n    \n    # 2) Test missing required fields produce validation errors\n    # Test missing username\n    payload_missing_username = {\n        \"email\": \"missingusername@example.com\",\n        \"password\": \"pass1234\"\n    }\n    response_missing_username = requests.post(\n        url=f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n        json=payload_missing_username,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_missing_username.status_code == 400, f\"Expected 400 for missing username, got {response_missing_username.status_code}\"\n\n    # Test missing email\n    payload_missing_email = {\n        \"username\": \"userwithoutemail\",\n        \"password\": \"pass1234\"\n    }\n    response_missing_email = requests.post(\n        url=f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n        json=payload_missing_email,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_missing_email.status_code == 400, f\"Expected 400 for missing email, got {response_missing_email.status_code}\"\n\n    # Test missing password\n    payload_missing_password = {\n        \"username\": \"userwithoutpassword\",\n        \"email\": \"userwithoutpassword@example.com\"\n    }\n    response_missing_password = requests.post(\n        url=f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n        json=payload_missing_password,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_missing_password.status_code == 400, f\"Expected 400 for missing password, got {response_missing_password.status_code}\"\n\n    # 3) Test invalid email format validation error\n    payload_invalid_email = {\n        \"username\": \"userinvalidemail\",\n        \"email\": \"not-an-email\",\n        \"password\": \"ValidPass123!\"\n    }\n    response_invalid_email = requests.post(\n        url=f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n        json=payload_invalid_email,\n        headers=headers,\n        timeout=TIMEOUT\n    )\n    assert response_invalid_email.status_code == 400, f\"Expected 400 for invalid email, got {response_invalid_email.status_code}\"\n\n    # 4) Test weak or too short password if system validates password strength (not required explicitly in PRD, so skipped)\n\ntest_user_registration_process()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 26, in test_user_registration_process\nAssertionError: Expected status code 201, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.438Z",
    "modified": "2025-12-15T20:04:20.496Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "df063f3e-83fa-4a0d-829b-6285b3dbadfa",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC003-email verification mechanism",
    "description": "Verify the email verification endpoint to ensure valid tokens confirm email addresses and invalid or expired tokens are handled correctly.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:3003\"\nVERIFY_EMAIL_ENDPOINT = \"/api/auth/verify-email/{}\"\nTIMEOUT = 30\n\ndef test_email_verification_mechanism():\n    \"\"\"\n    Test the email verification mechanism by verifying:\n    - Successful verification with a valid token.\n    - Proper handling of invalid or expired tokens.\n    \"\"\"\n    invalid_tokens = [\n        \"invalidtoken123\",\n        \"expiredtoken456\",\n        \"!!@@##$$%%^^&&\"\n    ]\n    \n    for token in invalid_tokens:\n        url = BASE_URL + VERIFY_EMAIL_ENDPOINT.format(token)\n        try:\n            response = requests.get(url, timeout=TIMEOUT)\n            # For invalid or expired tokens, expect 400 status code\n            assert response.status_code == 400, (\n                f\"Expected status 400 for invalid token '{token}', got {response.status_code}\"\n            )\n        except (RequestException, Timeout) as e:\n            assert False, f\"Request failed for token '{token}': {e}\"\n\n    # Note: Without a mechanism to generate or retrieve a valid token from the API,\n    # we cannot test a successful verification scenario here.\n    # This test verifies the handling of invalid/expired tokens as per instructions.\n\ntest_email_verification_mechanism()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.444Z",
    "modified": "2025-12-15T20:04:34.933Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "ddd78efd-f46e-41ef-be0f-c0a56f6e9625",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC004-jwt token refresh",
    "description": "Test the JWT token refresh endpoint to confirm new tokens are issued for valid refresh tokens and invalid tokens are rejected.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\ndef test_jwt_token_refresh():\n    # First, register a new user to obtain initial tokens (access and refresh)\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    refresh_url = f\"{BASE_URL}/api/auth/refresh\"\n\n    user_data = {\n        \"username\": \"testuser_jwt_refresh\",\n        \"email\": \"testuser_jwt_refresh@example.com\",\n        \"password\": \"TestPass123!\"\n    }\n\n    # Register user\n    try:\n        r = requests.post(register_url, json=user_data, timeout=TIMEOUT)\n        assert r.status_code == 201 or r.status_code == 400, f\"Unexpected status code on register: {r.status_code}\"\n        # If 201, registration successful; if 400, user may already exist\n    except requests.RequestException as e:\n        assert False, f\"Registration request failed: {e}\"\n\n    # Login user to get access token and refresh token\n    login_data = {\n        \"username\": user_data[\"username\"],\n        \"password\": user_data[\"password\"]\n    }\n\n    try:\n        r = requests.post(login_url, json=login_data, timeout=TIMEOUT)\n        if r.status_code == 401:\n            assert False, \"Login failed with 401 Unauthorized. User may not be verified. Cannot proceed with token refresh test.\"\n        assert r.status_code == 200, f\"Login failed with status code {r.status_code}\"\n        login_resp = r.json()\n        # Expect JWT token (assume \"accessToken\" and \"refreshToken\" keys or \"token\" and \"refreshToken\")\n        assert \"refreshToken\" in login_resp or \"refresh_token\" in login_resp or \"token\" in login_resp, \"No token found in login response\"\n        # Extract refresh token\n        refresh_token = None\n        if \"refreshToken\" in login_resp:\n            refresh_token = login_resp[\"refreshToken\"]\n        elif \"refresh_token\" in login_resp:\n            refresh_token = login_resp[\"refresh_token\"]\n        elif \"token\" in login_resp:\n            # If only access token provided, we cannot test refresh, skip test\n            assert False, \"No refresh token provided in login response\"\n        else:\n            assert False, \"Refresh token not found in login response\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Test refreshing JWT token with valid refresh token\n    try:\n        payload = {\"refreshToken\": refresh_token}\n        r = requests.post(refresh_url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 200, f\"Valid refresh token request failed with status {r.status_code}\"\n        resp_json = r.json()\n        assert isinstance(resp_json, dict), \"Refresh response is not a JSON object\"\n        assert any(k in resp_json for k in [\"accessToken\", \"token\"]), \"New access token not found in refresh response\"\n    except requests.RequestException as e:\n        assert False, f\"Refresh request failed: {e}\"\n\n    # Test refreshing JWT token with invalid/expired token\n    try:\n        invalid_payload = {\"refreshToken\": \"invalid_or_expired_refresh_token_value\"}\n        r = requests.post(refresh_url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert r.status_code == 401, f\"Invalid refresh token should return 401, got {r.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Invalid refresh request failed: {e}\"\n\ntest_jwt_token_refresh()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 21, in test_jwt_token_refresh\nAssertionError: Unexpected status code on register: 429\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.451Z",
    "modified": "2025-12-15T20:04:43.362Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "d0df7cdf-a307-47a6-bf7d-14f4355007db",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC005-get current user profile",
    "description": "Test retrieval of the current authenticated user's profile data with proper authorization.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\ndef test_get_current_user_profile():\n    # First, login to get a valid JWT token for authorization\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"username\": \"testuser\",\n        \"password\": \"TestPassword123!\"\n    }\n    try:\n        login_response = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status code {login_response.status_code}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\")  # Accept common keys\n        assert token is not None, \"JWT token not found in login response\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {str(e)}\"\n\n    # Use the JWT token to get the current user profile\n    profile_url = f\"{BASE_URL}/api/users/profile\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    try:\n        profile_response = requests.get(profile_url, headers=headers, timeout=TIMEOUT)\n        assert profile_response.status_code == 200, f\"Failed to get user profile, status code {profile_response.status_code}\"\n        profile_data = profile_response.json()\n        assert isinstance(profile_data, dict), \"Profile response is not a JSON object\"\n        # Validate expected fields are present (typical user profile fields)\n        expected_fields = [\"username\", \"email\"]\n        missing_fields = [field for field in expected_fields if field not in profile_data]\n        assert not missing_fields, f\"Missing fields in profile response: {missing_fields}\"\n    except requests.RequestException as e:\n        assert False, f\"Profile request failed: {str(e)}\"\n\ntest_get_current_user_profile()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 15, in test_get_current_user_profile\nAssertionError: Login failed with status code 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.458Z",
    "modified": "2025-12-15T20:04:18.762Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "d6c1b67f-9ecb-433e-9585-2568266d0729",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC006-update user profile",
    "description": "Validate updating user profile fields such as email and display name with proper authorization and data validation.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\n# Replace these with valid test user credentials\nTEST_USERNAME = f\"testuser_{uuid.uuid4().hex[:8]}\"\nTEST_EMAIL = f\"{TEST_USERNAME}@example.com\"\nTEST_PASSWORD = \"TestPass123!\"\n\ndef test_update_user_profile():\n    session = requests.Session()\n    try:\n        # Register a new user\n        register_payload = {\n            \"username\": TEST_USERNAME,\n            \"email\": TEST_EMAIL,\n            \"password\": TEST_PASSWORD\n        }\n        register_resp = session.post(f\"{BASE_URL}/api/auth/register\", json=register_payload, timeout=TIMEOUT)\n        assert register_resp.status_code == 201, f\"User registration failed: {register_resp.text}\"\n\n        # Normally email verification token would be sent by email, \n        # but since no details provided, try to login directly. If verification required, login will fail.\n        # So, skip verification step unless API allows. We'll attempt login, expecting 200 or 401.\n        login_payload = {\n            \"username\": TEST_USERNAME,\n            \"password\": TEST_PASSWORD\n        }\n        login_resp = session.post(f\"{BASE_URL}/api/auth/login\", json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"token\")\n        assert token, \"JWT token not found in login response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Get current profile to compare later\n        profile_resp = session.get(f\"{BASE_URL}/api/users/profile\", headers=headers, timeout=TIMEOUT)\n        assert profile_resp.status_code == 200, f\"Get profile failed: {profile_resp.text}\"\n        profile_before = profile_resp.json()\n        assert \"email\" in profile_before and (\"display_name\" in profile_before or True)  # Optional field 'display_name'\n\n        # Prepare new profile data to update\n        new_email = f\"updated_{TEST_USERNAME}@example.com\"\n        new_display_name = f\"DisplayName_{uuid.uuid4().hex[:6]}\"\n        update_payload = {\n            \"email\": new_email,\n            \"display_name\": new_display_name\n        }\n\n        # Send PATCH request to update profile\n        update_resp = session.patch(f\"{BASE_URL}/api/users/profile\", headers=headers, json=update_payload, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Profile update failed: {update_resp.text}\"\n        updated_profile = update_resp.json()\n\n        # Validate updated fields in response\n        assert updated_profile.get(\"email\") == new_email, f\"Email not updated correctly: {updated_profile.get('email')}\"\n        assert updated_profile.get(\"display_name\") == new_display_name, f\"Display name not updated correctly: {updated_profile.get('display_name')}\"\n\n        # Retrieve profile again to ensure update persisted\n        profile_after_resp = session.get(f\"{BASE_URL}/api/users/profile\", headers=headers, timeout=TIMEOUT)\n        assert profile_after_resp.status_code == 200, f\"Get profile after update failed: {profile_after_resp.text}\"\n        profile_after = profile_after_resp.json()\n\n        # Confirm updated fields match\n        assert profile_after.get(\"email\") == new_email, \"Updated email not persisted\"\n        assert profile_after.get(\"display_name\") == new_display_name, \"Updated display name not persisted\"\n\n        # Test data validation: try updating with invalid email format\n        invalid_update_payload = {\n            \"email\": \"invalid-email-format\",\n        }\n        invalid_resp = session.patch(f\"{BASE_URL}/api/users/profile\", headers=headers, json=invalid_update_payload, timeout=TIMEOUT)\n        # The specification does not detail error code for validation error here,\n        # assume 400 Bad Request for invalid data\n        assert invalid_resp.status_code == 400 or invalid_resp.status_code == 422, f\"Invalid email format accepted: {invalid_resp.text}\"\n\n        # Test unauthorized access: try update without auth header\n        unauth_resp = session.patch(f\"{BASE_URL}/api/users/profile\", json=update_payload, timeout=TIMEOUT)\n        assert unauth_resp.status_code == 401, f\"Unauthorized update allowed: {unauth_resp.text}\"\n\n    finally:\n        # Cleanup: delete the test user if API supports it\n        # No user delete endpoint specified in PRD; skip deletion\n        session.close()\n\ntest_update_user_profile()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 22, in test_update_user_profile\nAssertionError: User registration failed: Too many registration attempts, please try again later.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.465Z",
    "modified": "2025-12-15T20:05:00.315Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "23b7374d-9b19-4ad3-b026-a8a1ab4670a4",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC007-change user password",
    "description": "Test the password change endpoint to ensure current password verification and successful update to new password.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\ndef test_change_user_password():\n    # Credentials for test user\n    test_username = \"testuser_tc007\"\n    test_email = \"testuser_tc007@example.com\"\n    initial_password = \"InitialPass123!\"\n    new_password = \"NewPass123!\"\n    \n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Register the test user\n    register_payload = {\n        \"username\": test_username,\n        \"email\": test_email,\n        \"password\": initial_password\n    }\n\n    try:\n        reg_resp = requests.post(f\"{BASE_URL}/api/auth/register\", json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed: {reg_resp.status_code} {reg_resp.text}\"\n\n        # Normally, email verification is required, but no email token provided in test plan or instructions\n        # Attempting login directly to get token (assuming no email verification enforced for test or backend auto-verifies)\n        login_payload = {\n            \"username\": test_username,\n            \"password\": initial_password\n        }\n        login_resp = requests.post(f\"{BASE_URL}/api/auth/login\", json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.status_code} {login_resp.text}\"\n        auth_token = login_resp.json().get(\"token\")\n        assert auth_token, \"No auth token received after login\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {auth_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Test changing password with correct current password\n        change_pass_payload = {\n            \"currentPassword\": initial_password,\n            \"newPassword\": new_password\n        }\n        change_pass_resp = requests.post(f\"{BASE_URL}/api/users/change-password\", json=change_pass_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert change_pass_resp.status_code == 200, f\"Password change failed (correct current password): {change_pass_resp.status_code} {change_pass_resp.text}\"\n\n        # Verify login with new password now works\n        login_new_payload = {\n            \"username\": test_username,\n            \"password\": new_password\n        }\n        login_new_resp = requests.post(f\"{BASE_URL}/api/auth/login\", json=login_new_payload, headers=headers, timeout=TIMEOUT)\n        assert login_new_resp.status_code == 200, f\"Login failed with new password: {login_new_resp.status_code} {login_new_resp.text}\"\n\n        # Test changing password with incorrect current password\n        change_pass_bad_payload = {\n            \"currentPassword\": \"WrongPass123!\",\n            \"newPassword\": \"DoesNotMatter123!\"\n        }\n        change_pass_bad_resp = requests.post(f\"{BASE_URL}/api/users/change-password\", json=change_pass_bad_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert change_pass_bad_resp.status_code == 400, f\"Password change succeeded with wrong current password: {change_pass_bad_resp.status_code} {change_pass_bad_resp.text}\"\n\n    finally:\n        # Cleanup: Delete the created user if possible\n        # No direct API described for deleting user, attempt via profile patch or assume test environment handles cleanup\n        # If deletion API existed, a cleanup call would be here.\n        pass\n\ntest_change_user_password()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 74, in <module>\n  File \"<string>\", line 26, in test_change_user_password\nAssertionError: Registration failed: 429 Too many registration attempts, please try again later.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.471Z",
    "modified": "2025-12-15T20:04:55.633Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "3e905575-2402-4df9-88ac-4bd4a720350d",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC008-project creation and retrieval",
    "description": "Verify creating a new project with required fields and retrieving all projects for the authenticated user.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\n# Replace these with valid credentials for an existing user to authenticate and get JWT token\nTEST_USERNAME = \"testuser\"\nTEST_PASSWORD = \"testpassword\"\n\ndef test_project_creation_and_retrieval():\n    # Authenticate user to get JWT token\n    auth_url = f\"{BASE_URL}/api/auth/login\"\n    auth_payload = {\n        \"username\": TEST_USERNAME,\n        \"password\": TEST_PASSWORD\n    }\n    try:\n        auth_response = requests.post(auth_url, json=auth_payload, timeout=TIMEOUT)\n        assert auth_response.status_code == 200, f\"Login failed with status {auth_response.status_code}\"\n        auth_data = auth_response.json()\n        token = auth_data.get(\"token\")\n        assert token is not None, \"JWT token not found in login response\"\n    except Exception as e:\n        raise AssertionError(f\"Authentication failed: {e}\")\n\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    created_project_id = None\n    try:\n        # Create a new project with required fields (name)\n        create_project_url = f\"{BASE_URL}/api/projects\"\n        project_payload = {\n            \"name\": \"Test Project via API\",\n            \"description\": \"Test project created during automated testing.\"\n        }\n        create_response = requests.post(create_project_url, json=project_payload, headers=headers, timeout=TIMEOUT)\n        assert create_response.status_code == 201, f\"Project creation failed with status {create_response.status_code}\"\n        project_data = create_response.json()\n        created_project_id = project_data.get(\"id\") or project_data.get(\"projectId\") or project_data.get(\"project_id\")\n        assert created_project_id is not None, \"Created project ID not found in response\"\n\n        # Retrieve all projects for authenticated user\n        get_projects_url = f\"{BASE_URL}/api/projects\"\n        get_response = requests.get(get_projects_url, headers=headers, timeout=TIMEOUT)\n        assert get_response.status_code == 200, f\"Getting projects failed with status {get_response.status_code}\"\n        projects_list = get_response.json()\n        assert isinstance(projects_list, list), \"Projects list response is not a list\"\n\n        # Verify the created project is in the list of projects\n        project_ids = [proj.get(\"id\") for proj in projects_list if isinstance(proj, dict)]\n        assert created_project_id in project_ids, \"Created project is not found in the projects list\"\n\n    finally:\n        # Cleanup: Delete the created project to maintain test isolation\n        if created_project_id:\n            delete_project_url = f\"{BASE_URL}/api/projects/{created_project_id}\"\n            try:\n                del_response = requests.delete(delete_project_url, headers=headers, timeout=TIMEOUT)\n                assert del_response.status_code == 200, f\"Deleting project failed with status {del_response.status_code}\"\n            except Exception as e:\n                # Log or raise error depending on environment\n                raise AssertionError(f\"Cleanup failed: could not delete project {created_project_id} - {e}\")\n\ntest_project_creation_and_retrieval()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 19, in test_project_creation_and_retrieval\nAssertionError: Login failed with status 401\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 24, in test_project_creation_and_retrieval\nAssertionError: Authentication failed: Login failed with status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.528Z",
    "modified": "2025-12-15T20:04:34.939Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "2a450bea-ad48-4f8d-b443-c04520bd1c77",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC009-site registration from wordpress plugin",
    "description": "Test the self-registration of a site from the WordPress plugin using a valid registration token, site URL, and API key, including handling invalid tokens.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\ndef test_site_registration_from_wordpress_plugin():\n    url_register = f\"{BASE_URL}/api/sites/register-from-wordpress\"\n    \n    # Sample valid registration token, site URL, and API key\n    valid_registration_token = \"valid_sample_token_123\"\n    site_url = \"https://example-wordpress-site.com\"\n    api_key = \"sample_api_key_456\"\n    \n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # 1. Test successful registration with valid data\n    payload_valid = {\n        \"registration_token\": valid_registration_token,\n        \"site_url\": site_url,\n        \"api_key\": api_key\n    }\n    try:\n        response = requests.post(url_register, json=payload_valid, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed during valid registration attempt: {e}\"\n    \n    assert response.status_code == 201, f\"Expected 201 Created for valid registration but got {response.status_code}\"\n    json_resp = response.json()\n    # Check response content: depending on implementation, might return site info or an ID.\n    assert isinstance(json_resp, dict), \"Response JSON is not a dictionary\"\n    # Optionally check that site_url and api_key appear in response or that site id is present\n    assert \"site_url\" in json_resp or \"id\" in json_resp, \"Response missing site_url or id\"\n    \n    # 2. Test registration with invalid token\n    invalid_payload = {\n        \"registration_token\": \"invalid_token_xyz\",\n        \"site_url\": \"https://example-invalid-site.com\",\n        \"api_key\": api_key\n    }\n    try:\n        response_invalid = requests.post(url_register, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed during invalid registration attempt: {e}\"\n    \n    assert response_invalid.status_code == 400, f\"Expected 400 Bad Request for invalid token but got {response_invalid.status_code}\"\n    json_invalid = response_invalid.json()\n    # The error message or code is expected\n    assert \"error\" in json_invalid or \"message\" in json_invalid, \"Error response expected for invalid token registration\"\n\ntest_site_registration_from_wordpress_plugin()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 52, in <module>\n  File \"<string>\", line 29, in test_site_registration_from_wordpress_plugin\nAssertionError: Expected 201 Created for valid registration but got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.537Z",
    "modified": "2025-12-15T20:04:34.936Z"
  },
  {
    "projectId": "c3406546-0d6a-46c3-b358-e33d1b1a3aad",
    "testId": "efd8baae-154a-4845-b785-23c88f557704",
    "userId": "5438c428-e021-70db-5c37-818354752575",
    "title": "TC010-purchase placement with billing",
    "description": "Validate the purchase placement endpoint to ensure placement purchases are processed correctly with sufficient balance, proper scheduling, and auto-renewal options.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:3003\"\nTIMEOUT = 30\n\n# These credentials should be valid in the system or replaced accordingly\nTEST_USERNAME = \"testuser_tc010\"\nTEST_EMAIL = \"testuser_tc010@example.com\"\nTEST_PASSWORD = \"TestPassword123!\"\n\ndef test_purchase_placement_with_billing():\n    session = requests.Session()\n    headers = {\"Content-Type\": \"application/json\"}\n    auth_token = None\n    project_id = None\n    site_id = None\n    link_id = None  # or article_id depending on type\n\n    try:\n        # 1. Register user\n        register_payload = {\n            \"username\": TEST_USERNAME,\n            \"email\": TEST_EMAIL,\n            \"password\": TEST_PASSWORD\n        }\n        resp = session.post(f\"{BASE_URL}/api/auth/register\", json=register_payload, timeout=TIMEOUT, headers=headers)\n        assert resp.status_code == 201, f\"User registration failed: {resp.text}\"\n\n        # 2. Login user to get JWT token\n        login_payload = {\n            \"username\": TEST_USERNAME,\n            \"password\": TEST_PASSWORD\n        }\n        resp = session.post(f\"{BASE_URL}/api/auth/login\", json=login_payload, timeout=TIMEOUT, headers=headers)\n        assert resp.status_code == 200, f\"User login failed: {resp.text}\"\n        token = resp.json().get(\"token\") or resp.json().get(\"accessToken\")  # based on implementation naming\n        assert token, \"No token received on login\"\n        auth_token = token\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {auth_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # 3. Create project\n        project_payload = {\n            \"name\": \"Test Project for TC010\",\n            \"description\": \"Project created for testing purchase placement.\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/projects\", json=project_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Project creation failed: {resp.text}\"\n        project = resp.json()\n        project_id = project.get(\"id\") or project.get(\"projectId\")\n        assert project_id is not None, \"Project ID missing after creation\"\n\n        # 4. Create site\n        site_payload = {\n            \"site_url\": \"http://example-tc010-site.com\",\n            \"site_type\": \"wordpress\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/sites\", json=site_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Site creation failed: {resp.text}\"\n        site = resp.json()\n        site_id = site.get(\"id\")\n        assert site_id is not None, \"Site ID missing after creation\"\n\n        # 5. Add link (content) to project to have contentIds for purchase\n        link_payload = {\n            \"anchor_text\": \"Test Anchor for TC010\",\n            \"url\": \"http://example-tc010-link.com\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/projects/{project_id}/links\", json=link_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Adding link failed: {resp.text}\"\n        link = resp.json()\n        link_id = link.get(\"id\") or link.get(\"linkId\")\n        assert link_id is not None, \"Link ID missing after creation\"\n\n        # 6. Deposit sufficient balance to user account to cover purchase\n        deposit_payload = {\n            \"amount\": 100.0,\n            \"description\": \"Deposit for placement purchase testing\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/billing/deposit\", json=deposit_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Deposit failed: {resp.text}\"\n\n        # 7. Get balance and assert sufficient balance > 0\n        resp = session.get(f\"{BASE_URL}/api/billing/balance\", headers=auth_headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Get balance failed: {resp.text}\"\n        balance_info = resp.json()\n        balance = balance_info.get(\"balance\")\n        assert balance is not None and balance > 0, \"Insufficient balance for purchase test\"\n\n        # 8. Prepare purchase payload with scheduling and autoRenewal\n        scheduled_date_iso = (datetime.datetime.utcnow() + datetime.timedelta(days=1)).isoformat() + \"Z\"\n        purchase_payload = {\n            \"projectId\": project_id,\n            \"siteId\": site_id,\n            \"type\": \"link\",\n            \"contentIds\": [link_id],\n            \"scheduledDate\": scheduled_date_iso,\n            \"autoRenewal\": True\n        }\n        resp = session.post(f\"{BASE_URL}/api/billing/purchase\", json=purchase_payload, headers=auth_headers, timeout=TIMEOUT)\n\n        # 9. Validate purchase\n        if resp.status_code == 200:\n            purchase_resp = resp.json()\n            assert \"placementId\" in purchase_resp or \"id\" in purchase_resp, \"Purchase response missing placementId\"\n        elif resp.status_code == 400:\n            # Could be insufficient balance, fail accordingly\n            error_msg = resp.json().get(\"message\", resp.text)\n            assert False, f\"Purchase failed with 400 error: {error_msg}\"\n        else:\n            assert False, f\"Unexpected status code on purchase: {resp.status_code} - {resp.text}\"\n\n    finally:\n        # Cleanup: Delete created link, project, site to maintain test isolation\n        if auth_token:\n            auth_headers = {\n                \"Authorization\": f\"Bearer {auth_token}\",\n                \"Content-Type\": \"application/json\"\n            }\n            if link_id and project_id:\n                try:\n                    session.delete(f\"{BASE_URL}/api/projects/{project_id}/links/{link_id}\", headers=auth_headers, timeout=TIMEOUT)\n                except Exception:\n                    pass\n            if project_id:\n                try:\n                    session.delete(f\"{BASE_URL}/api/projects/{project_id}\", headers=auth_headers, timeout=TIMEOUT)\n                except Exception:\n                    pass\n            if site_id:\n                try:\n                    session.delete(f\"{BASE_URL}/api/sites/{site_id}\", headers=auth_headers, timeout=TIMEOUT)\n                except Exception:\n                    pass\n            # Optionally delete user if API exists (not specified)\n\ntest_purchase_placement_with_billing()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 141, in <module>\n  File \"<string>\", line 28, in test_purchase_placement_with_billing\nAssertionError: User registration failed: {\"error\":\"Passwords do not match\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-15T20:03:21.544Z",
    "modified": "2025-12-15T20:04:41.942Z"
  }
]
