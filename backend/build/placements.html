<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Купить ссылки - Link Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/sidebar.css">
    <style>
        /* Sticky action bar (neutral gray bar at bottom) */
        #stickyActionBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            padding: 15px 0;
            display: none; /* Hidden by default */
            transition: all 0.3s ease;
        }

        #stickyActionBar.show {
            display: block;
        }

        #stickyActionBar .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        #stickyActionBar .btn {
            min-width: 140px;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #stickyActionBar .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        #stickyActionBar .badge {
            font-size: 0.85rem;
            padding: 0.35em 0.6em;
            margin-left: 6px;
        }

        #stickyActionBar .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Add bottom padding to body to prevent content hiding behind bar */
        body.sticky-bar-active {
            padding-bottom: 80px;
        }

        /* Pagination buttons - white when not selected */
        .btn-group .btn-check + .btn-outline-dark {
            background-color: #fff;
            color: #212529;
            border-color: #dee2e6;
        }
        .btn-group .btn-check + .btn-outline-dark:hover {
            background-color: #f8f9fa;
            border-color: #adb5bd;
        }
        .btn-group .btn-check:checked + .btn-outline-dark {
            background-color: #212529;
            color: #fff;
            border-color: #212529;
        }

        /* Table styling - compact font */
        .table {
            font-size: 0.75rem;
        }

        .table th, .table td {
            padding: 0.4rem 0.5rem;
        }

        /* "Контент" column (3rd) - show full text */
        .table th:nth-child(3),
        .table td:nth-child(3) {
            white-space: normal;
            min-width: 150px;
        }

        /* Content dropdown - show full text without truncation */
        .content-dropdown {
            min-width: 250px !important;
            max-width: 400px !important;
            width: auto !important;
        }

        .content-dropdown option {
            white-space: normal !important;
            overflow: visible !important;
            text-overflow: clip !important;
            padding: 8px 12px;
        }
    </style>
</head>
<body>
    <!-- Content will be wrapped by sidebar.js -->

    <div class="container mt-4">
        <h1 class="mb-4">Купить ссылки</h1>

        <!-- Step 1 & 2: Project and Content Type Selection -->
        <div class="card mb-4">
            <div class="card-body">
                <h5 class="card-title">Выбор проекта и типа контента</h5>
                <div class="row">
                    <div class="col-md-6">
                        <label for="projectSelect" class="form-label fw-bold">Select Project</label>
                        <select class="form-select" id="projectSelect">
                            <option value="">Select project...</option>
                        </select>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label fw-bold">Content Type</label>
                        <div class="d-flex gap-3 align-items-center" style="height: 38px;">
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="contentType" id="typeLinks" value="links">
                                <label class="form-check-label" for="typeLinks">
                                    <i class="bi bi-link-45deg"></i> Main page
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="contentType" id="typeArticles" value="articles">
                                <label class="form-check-label" for="typeArticles">
                                    <i class="bi bi-file-text"></i> Articles
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Publication Date Selection -->
        <div class="card mb-4">
            <div class="card-body">
                <h5 class="card-title">Настройки публикации</h5>
                <div class="row">
                    <div class="col-md-12">
                        <label class="form-label fw-bold">Дата публикации</label>
                        <div class="mb-2">
                            <input class="form-check-input" type="radio" name="publishType" id="publishImmediate" value="immediate" checked>
                            <label class="form-check-label" for="publishImmediate">
                                <i class="bi bi-lightning-fill"></i> Опубликовать сразу
                            </label>
                        </div>
                        <div class="mb-2">
                            <input class="form-check-input" type="radio" name="publishType" id="publishDistributed" value="distributed">
                            <label class="form-check-label" for="publishDistributed">
                                <i class="bi bi-calendar-range"></i> Отложенная публикация (период)
                            </label>
                        </div>
                        <div id="distributedPeriodDiv" style="display: none;" class="mt-3">
                            <label for="distributionPeriod" class="form-label">Период распределения:</label>
                            <input type="range" class="form-range" id="distributionPeriod"
                                   min="5" max="90" value="30" step="1">
                            <div class="d-flex justify-content-between mt-1">
                                <small class="text-muted">5 дней</small>
                                <small class="text-muted fw-bold">Выбрано: <span id="selectedDays">30</span> дней</small>
                                <small class="text-muted">90 дней</small>
                            </div>
                            <div id="distributionPreview" class="mt-2 p-2 bg-light rounded" style="display: none;">
                                <small class="text-muted">
                                    <i class="bi bi-info-circle"></i> <span id="distributionPreviewText"></span>
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Sites Table -->
        <div id="sitesTableDiv" style="display: none;">
            <div class="card mb-4">
                <div class="card-body">
                    <h5 class="card-title">Доступные сайты для размещения</h5>

                    <!-- Active filters info -->
                    <div class="mb-3">
                        <span id="activeFiltersInfo"></span>
                    </div>

                    <!-- Hide Already Purchased Filter -->
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="hideAlreadyPurchasedCheckbox" checked>
                            <label class="form-check-label" for="hideAlreadyPurchasedCheckbox">
                                Скрыть купленные
                            </label>
                        </div>
                    </div>

                    <!-- GEO Filter -->
                    <div class="mb-3">
                        <label for="geoFilter" class="form-label">Фильтр по GEO:</label>
                        <select class="form-select form-select-sm" id="geoFilter" style="max-width: 200px;">
                            <option value="">Все регионы</option>
                            <!-- Options will be populated dynamically -->
                        </select>
                    </div>

                    <!-- Pagination Controls -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div class="d-flex align-items-center gap-2">
                            <div class="btn-group" role="group">
                                <input type="radio" class="btn-check" name="sitesPerPage" id="sites100" value="100" checked>
                                <label class="btn btn-outline-dark btn-sm" for="sites100">100</label>

                                <input type="radio" class="btn-check" name="sitesPerPage" id="sites300" value="300">
                                <label class="btn btn-outline-dark btn-sm" for="sites300">300</label>

                                <input type="radio" class="btn-check" name="sitesPerPage" id="sites500" value="500">
                                <label class="btn btn-outline-dark btn-sm" for="sites500">500</label>
                            </div>
                            <span class="text-muted" id="sitesCountInfo"></span>
                        </div>
                        <div id="paginationControls">
                            <!-- Pagination buttons will be inserted here -->
                        </div>
                    </div>

                    <div class="table-responsive">
                        <table class="table table-sm table-hover table-bordered">
                            <thead class="table-light">
                                <tr>
                                    <th style="width: 50px;">
                                        <input type="checkbox" id="selectAllSites" onclick="toggleAllSites()">
                                    </th>
                                    <th>Сайт</th>
                                    <th>Контент</th>
                                    <th>DR</th>
                                    <th>DA</th>
                                    <th>TF</th>
                                    <th>CF</th>
                                    <th>RD</th>
                                    <th>RDm</th>
                                    <th>Norm</th>
                                    <th>KW</th>
                                    <th>Traf</th>
                                    <th>GEO</th>
                                    <th>Тип</th>
                                    <th>Слоты</th>
                                    <th>Цена</th>
                                    <th>Статус</th>
                                    <th>Видимость</th>
                                </tr>
                            </thead>
                            <tbody id="sitesTableBody">
                                <tr>
                                    <td colspan="18" class="text-center text-muted">
                                        Выберите проект и тип контента выше
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Bottom pagination (duplicate of top pagination) -->
                    <nav aria-label="Sites pagination bottom" class="mt-3" id="bottomPaginationNav" style="display: none;">
                        <ul class="pagination justify-content-center" id="bottomPaginationControls">
                            <!-- Pagination buttons will be inserted here -->
                        </ul>
                    </nav>

                    <!-- Bottom purchase button -->
                    <div class="text-center mt-4 mb-4" id="bottomPurchaseDiv" style="display: none;">
                        <button type="button" class="btn btn-dark btn-lg" onclick="createPlacement()" id="bottomPurchaseBtn" disabled>
                            <i class="bi bi-cart-check-fill"></i> Купить
                            <span class="badge bg-light text-dark ms-2" id="bottomPurchaseBadge">0</span>
                            <span class="badge bg-light text-dark ms-1" id="bottomPurchaseTotalBadge">$0.00</span>
                        </button>
                    </div>

                </div>
            </div>
        </div>

        <!-- Sticky Action Bar (purple bar at bottom with 3 buttons) -->
        <div id="stickyActionBar">
            <div class="action-buttons">
                <button type="button" class="btn btn-outline-dark btn-lg" id="stickyWhitelistBtn" onclick="addSelectedToWhitelist()" disabled>
                    <i class="bi bi-check-circle-fill"></i> Whitelist
                    <span class="badge bg-dark" id="whitelistBadge">0</span>
                </button>
                <button type="button" class="btn btn-dark btn-lg" id="stickyPurchaseBtn" onclick="createPlacement()" disabled>
                    <i class="bi bi-cart-check-fill"></i> Купить
                    <span class="badge bg-light text-dark" id="purchaseBadge">0</span>
                    <span class="badge bg-light text-dark ms-1" id="purchaseTotalBadge">$0.00</span>
                </button>
                <button type="button" class="btn btn-outline-dark btn-lg" id="stickyBlacklistBtn" onclick="addSelectedToBlacklist()" disabled>
                    <i class="bi bi-x-circle-fill"></i> Blacklist
                    <span class="badge bg-dark" id="blacklistBadge">0</span>
                </button>
            </div>
        </div>

            <!-- Whitelist/Blacklist Actions -->
            <div class="row mt-4" id="listActionsDiv" style="display: none;">
                <div class="col-12">
                    <div class="card border">
                        <div class="card-header bg-light border-bottom">
                            <span><i class="bi bi-gear"></i> Управление списками</span>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <!-- Whitelist Section -->
                                <div class="col-md-6 mb-3 mb-md-0">
                                    <div class="d-flex align-items-center mb-2">
                                        <i class="bi bi-check-circle text-secondary me-2"></i>
                                        <strong>Whitelist</strong>
                                        <span class="badge bg-secondary ms-2" id="whitelistTotal">0</span>
                                    </div>
                                    <div class="d-flex gap-2 flex-wrap">
                                        <button type="button" class="btn btn-outline-dark btn-sm" id="addToWhitelistBtn" onclick="addSelectedToWhitelist()" disabled>
                                            <i class="bi bi-plus"></i> Добавить (<span id="whitelistCount">0</span>)
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="importWhitelist()">
                                            <i class="bi bi-upload"></i> Импорт
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="toggleWhitelistView()">
                                            <i class="bi bi-eye"></i> Показать
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="clearWhitelist()">
                                            <i class="bi bi-trash"></i> Очистить
                                        </button>
                                    </div>
                                </div>
                                <!-- Blacklist Section -->
                                <div class="col-md-6">
                                    <div class="d-flex align-items-center mb-2">
                                        <i class="bi bi-x-circle text-secondary me-2"></i>
                                        <strong>Blacklist</strong>
                                        <span class="badge bg-secondary ms-2" id="blacklistTotal">0</span>
                                    </div>
                                    <div class="d-flex gap-2 flex-wrap">
                                        <button type="button" class="btn btn-outline-dark btn-sm" id="addToBlacklistBtn" onclick="addSelectedToBlacklist()" disabled>
                                            <i class="bi bi-plus"></i> Добавить (<span id="blacklistCount">0</span>)
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="importBlacklist()">
                                            <i class="bi bi-upload"></i> Импорт
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="toggleBlacklistView()">
                                            <i class="bi bi-eye"></i> Показать
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="clearBlacklist()">
                                            <i class="bi bi-trash"></i> Очистить
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import List Modal -->
    <div class="modal fade" id="importListModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="importListModalTitle">Import Domains</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted">Enter domains (one per line). Format: <code>site.com</code> or <code>https://site.com</code></p>
                    <textarea class="form-control" id="importDomainsText" rows="10" placeholder="example.com&#10;https://another-site.com&#10;third-site.org"></textarea>
                    <div class="mt-2">
                        <small class="text-muted">Only domains that exist in the system will be added.</small>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="processImportedDomains()">Import</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Modal for Async Batch Placements -->
    <div class="modal fade" id="progressModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header bg-purple text-white">
                    <h5 class="modal-title">
                        <i class="bi bi-hourglass-split"></i> Processing Batch Placement
                    </h5>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span id="progressStatus" class="fw-bold">Initializing...</span>
                            <span id="progressPercent" class="badge bg-purple">0%</span>
                        </div>
                        <div class="progress" style="height: 25px;">
                            <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                                 role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>

                    <div class="row text-center mb-3">
                        <div class="col-4">
                            <div class="border rounded p-2">
                                <div class="fs-4 fw-bold text-purple" id="progressTotal">0</div>
                                <small class="text-muted">Total Sites</small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="border rounded p-2">
                                <div class="fs-4 fw-bold text-success" id="progressSuccessful">0</div>
                                <small class="text-muted">Successful</small>
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="border rounded p-2">
                                <div class="fs-4 fw-bold text-danger" id="progressFailed">0</div>
                                <small class="text-muted">Failed</small>
                            </div>
                        </div>
                    </div>

                    <div id="progressResults" class="mt-3" style="max-height: 300px; overflow-y: auto; display: none;">
                        <h6 class="fw-bold">Results:</h6>
                        <div id="progressResultsList"></div>
                    </div>

                    <div id="progressErrors" class="mt-3 alert alert-danger" style="display: none;">
                        <h6 class="fw-bold">Errors:</h6>
                        <ul id="progressErrorsList" class="mb-0"></ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" id="cancelJobBtn" onclick="cancelCurrentJob()">
                        <i class="bi bi-x-circle"></i> Cancel Job
                    </button>
                    <button type="button" class="btn btn-secondary" id="closeProgressBtn" onclick="closeProgressModal()" style="display: none;">
                        Close
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/js/security.js"></script>
    <script src="/js/auth.js"></script>
    <script src="/js/api.js"></script>
    <script src="/js/sidebar.js"></script>
    <script>
        // Initialize sidebar navigation
        SidebarNav.init({
            activePage: 'purchase',
            pageTitle: 'Покупка ссылок',
            pageSubtitle: 'Выберите сайты для размещения'
        });

        let projects = [];
        let sites = [];
        let projectLinks = [];
        let projectArticles = [];
        let progressModal;
        let currentJobId = null;
        let pollInterval = null;
        let selectedContentType = null;
        let siteAssignments = {}; // { siteId: { contentId, contentName } }
        let nextContentIndex = 0; // Round-robin index for auto-assignment
        let sitesPerPage = 100; // Default sites per page
        let currentPage = 1;
        let filteredSites = []; // Sites after filtering by project placements
        let whitelist = new Set(); // Set of site IDs in whitelist (stored but not auto-applied)
        let blacklist = new Set(); // Set of site IDs in blacklist (stored but not auto-applied)
        let whitelistActive = false; // Whether to apply whitelist filter
        let blacklistActive = false; // Whether to apply blacklist filter
        let hideAlreadyPurchased = true; // Whether to hide already purchased sites (default: active)
        let selectedGeo = ''; // GEO filter value (empty = show all)
        let selectedSitesForList = new Set(); // Track selected sites (not for placement, but for list operations)
        let currentImportTarget = 'whitelist'; // 'whitelist' or 'blacklist'
        let importListModal;
        let hasAvailableContent = false; // Whether project has links/articles to purchase
        let userPricing = null; // Pricing data with user's discount

        /**
         * Mask URL for premium sites (DR >= 20 OR DA >= 30)
         * Admins and Gold tier (discount >= 20%) see all URLs
         * Format: elearning-reviews.org → elear***ws.org
         */
        function maskUrl(url, dr, da) {
            const currentUser = getCurrentUser();
            const userDiscount = userPricing?.link?.discount || 0;
            const isAdminUser = currentUser?.role === 'admin';

            // Admins and Gold+ users (discount >= 20%) see all URLs
            if (isAdminUser || userDiscount >= 20) {
                return url;
            }

            // Only mask premium sites (DR >= 20 OR DA >= 30)
            if (dr < 20 && da < 30) {
                return url;
            }

            // Handle subdomains: sub.domain.com -> take only main domain part
            const parts = url.split('.');
            if (parts.length < 2) return url; // Invalid format, return as is

            const domain = parts.pop(); // org, com, ru
            const name = parts.pop(); // main domain name (e.g., 'domain' from 'sub.domain.com')

            // Very short names (3 chars or less): show first + ***
            if (name.length <= 3) {
                return name.slice(0, 1) + '***.' + domain;
            }

            // Short names (4-6 chars): show first 2 + *** + last 1
            if (name.length <= 6) {
                return name.slice(0, 2) + '***' + name.slice(-1) + '.' + domain;
            }

            // Normal names (7+ chars): show first 4 + *** + last 2
            return name.slice(0, 4) + '***' + name.slice(-2) + '.' + domain;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            progressModal = new bootstrap.Modal(document.getElementById('progressModal'));
            importListModal = new bootstrap.Modal(document.getElementById('importListModal'));

            document.getElementById('projectSelect').addEventListener('change', onProjectSelectedNew);
            document.getElementById('typeLinks').addEventListener('change', onContentTypeSelected);
            document.getElementById('typeArticles').addEventListener('change', onContentTypeSelected);

            // Add event listeners for sites per page radio buttons
            document.querySelectorAll('input[name="sitesPerPage"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    sitesPerPage = parseInt(e.target.value);
                    currentPage = 1; // Reset to first page
                    renderSitesTable(); // Re-render with new page size
                });
            });

            // Add event listener for hide already purchased checkbox
            document.getElementById('hideAlreadyPurchasedCheckbox').addEventListener('change', async (e) => {
                hideAlreadyPurchased = e.target.checked;
                currentPage = 1; // Reset to first page

                // Re-load sites with filter if project and content type are selected
                const projectId = document.getElementById('projectSelect').value;
                if (projectId && selectedContentType) {
                    await loadSitesForPlacement(projectId, selectedContentType);
                }
            });

            // Add event listener for GEO filter dropdown
            document.getElementById('geoFilter').addEventListener('change', async (e) => {
                selectedGeo = e.target.value;
                currentPage = 1; // Reset to first page

                // Re-load sites with filter if project and content type are selected
                const projectId = document.getElementById('projectSelect').value;
                if (projectId && selectedContentType) {
                    await loadSitesForPlacement(projectId, selectedContentType);
                }
            });

            // Add event listeners for publication type radio buttons
            document.getElementById('publishImmediate').addEventListener('change', () => {
                document.getElementById('distributedPeriodDiv').style.display = 'none';
                updateCreateButtonState();
            });
            document.getElementById('publishDistributed').addEventListener('change', () => {
                document.getElementById('distributedPeriodDiv').style.display = 'block';
                updateDistributionPreview();
                updateCreateButtonState();
            });

            // Add event listener for distribution period slider (input event for real-time update)
            document.getElementById('distributionPeriod').addEventListener('input', (e) => {
                document.getElementById('selectedDays').textContent = e.target.value;
                updateDistributionPreview();
            });

            // Load projects and sites - auto-selection happens in loadProjects()
            await Promise.all([loadProjects(), loadSites(), loadPricing()]);

            // Load whitelist/blacklist from localStorage but DON'T apply filters
            loadListsFromStorage();
        });

        // Update GEO filter dropdown options from loaded sites
        function updateGeoFilterOptions() {
            const geoFilter = document.getElementById('geoFilter');
            const currentValue = geoFilter.value;

            // Collect unique GEO values from all sites
            const uniqueGeos = [...new Set(sites.map(site => site.geo || 'EN'))];

            // Sort alphabetically
            uniqueGeos.sort();

            // Rebuild options, preserving current selection
            geoFilter.innerHTML = '<option value="">Все регионы</option>' +
                uniqueGeos.map(geo =>
                    `<option value="${geo}" ${geo === currentValue ? 'selected' : ''}>${geo}</option>`
                ).join('');
        }

        async function loadPricing() {
            try {
                const response = await fetch('/api/billing/pricing', {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!response.ok) throw new Error('Failed to load pricing');
                const result = await response.json();
                userPricing = result.data;
            } catch (error) {
                console.error('Failed to load pricing:', error);
                // Fallback to base prices without discount
                userPricing = {
                    link: { finalPrice: 25.00 },
                    article: { finalPrice: 15.00 }
                };
            }
        }

        async function loadProjects() {
            try {
                projects = await ProjectsAPI.getAll();
                populateProjectFilter();

                // Auto-select project: last selected or first project
                if (projects.length > 0) {
                    setTimeout(async () => {
                        const projectSelect = document.getElementById('projectSelect');
                        const typeLinks = document.getElementById('typeLinks');

                        // Проверить сохранённый проект в localStorage
                        const lastProjectId = localStorage.getItem('lastSelectedProjectId');
                        let selectedProjectId = projects[0].id; // По умолчанию первый проект

                        // Если сохранённый проект существует в списке, используем его
                        if (lastProjectId && projects.find(p => p.id === parseInt(lastProjectId))) {
                            selectedProjectId = parseInt(lastProjectId);
                        }

                        projectSelect.value = selectedProjectId;
                        typeLinks.checked = true;
                        selectedContentType = 'links';

                        // Load project data first
                        const projectData = await ProjectsAPI.get(selectedProjectId);
                        projectLinks = projectData.links || [];
                        projectArticles = projectData.articles || [];

                        // Then load sites table
                        await loadSitesForPlacement(selectedProjectId, 'links');
                    }, 100);
                }
            } catch (error) {
                showNotification('Failed to load projects: ' + error.message, 'error');
            }
        }

        async function loadSites() {
            try {
                // Use marketplace endpoint to get public sites + user's own sites
                sites = await SitesAPI.getMarketplace();
            } catch (error) {
                showNotification('Failed to load sites: ' + error.message, 'error');
            }
        }

        function populateProjectFilter() {
            const select = document.getElementById('projectSelect');
            select.innerHTML = '<option value="">Select project...</option>' +
                projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
        }


        async function onProjectSelectedNew() {
            const projectId = document.getElementById('projectSelect').value;

            if (!projectId) {
                document.getElementById('sitesTableDiv').style.display = 'none';
                return;
            }

            // Сохранить выбранный проект в localStorage
            localStorage.setItem('lastSelectedProjectId', projectId);

            try {
                // Load project data
                const projectData = await ProjectsAPI.get(projectId);
                projectLinks = projectData.links || [];
                projectArticles = projectData.articles || [];

                // Auto-select Links and load sites
                document.getElementById('typeLinks').checked = true;
                selectedContentType = 'links';

                // Reset round-robin index
                nextContentIndex = 0;

                // Load sites table
                await loadSitesForPlacement(projectId, 'links');

                // Show sites table
                document.getElementById('sitesTableDiv').style.display = 'block';
            } catch (error) {
                showNotification('Failed to load project: ' + error.message, 'error');
            }
        }

        async function onContentTypeSelected() {
            selectedContentType = document.querySelector('input[name="contentType"]:checked')?.value;

            if (!selectedContentType) {
                document.getElementById('sitesTableDiv').style.display = 'none';
                return;
            }

            const projectId = document.getElementById('projectSelect').value;
            if (!projectId) return;

            // Reset round-robin index when content type changes
            nextContentIndex = 0;

            // Show sites table and load data
            document.getElementById('sitesTableDiv').style.display = 'block';
            await loadSitesForPlacement(projectId, selectedContentType);
        }

        async function loadSitesForPlacement(projectId, contentType) {
            try {
                // Get placements for this specific project with high limit to ensure we get ALL of them
                const placementsResponse = await fetch(`/api/placements?project_id=${projectId}&limit=500`, {
                    headers: { 'Authorization': `Bearer ${getAuthToken()}` }
                });
                const placementsData = await placementsResponse.json();
                const projectPlacements = placementsData.data || placementsData; // Extract data array if paginated

                console.log('Project placements loaded:', projectPlacements.length);
                console.log('Project ID:', projectId);

                console.log('Project placements:', projectPlacements);

                // Build map of sites with their content status (links and articles)
                // CRITICAL: Mark sites that already have placements for this project
                const sitesStatus = new Map();
                for (const placement of projectPlacements) {
                    if (!sitesStatus.has(placement.site_id)) {
                        sitesStatus.set(placement.site_id, { hasLinks: false, hasArticles: false });
                    }
                    const status = sitesStatus.get(placement.site_id);
                    // Use placement.type for reliable detection (link_count/article_count might be 0 in some cases)
                    if (placement.type === 'link' || placement.link_count > 0) status.hasLinks = true;
                    if (placement.type === 'article' || placement.article_count > 0) status.hasArticles = true;
                }

                // Get available content
                const availableContent = contentType === 'links' ? projectLinks : projectArticles;

                // Show warning if no content, but don't block site loading
                hasAvailableContent = availableContent.length > 0;
                if (!hasAvailableContent) {
                    showNotification(`Сначала добавьте ${contentType === 'links' ? 'ссылки' : 'гест-посты'} в проект`, 'warning');
                }

                // Apply whitelist/blacklist filtering ONLY if activated
                let sitesToShow = sites;

                // FIRST: Filter out sites that are not available for purchase
                sitesToShow = sitesToShow.filter(site => site.available_for_purchase !== false);

                // If whitelist is ACTIVE and not empty, show ONLY whitelist sites
                if (whitelistActive && whitelist.size > 0) {
                    sitesToShow = sitesToShow.filter(site => whitelist.has(site.id));
                }

                // If blacklist is ACTIVE and not empty, exclude blacklist sites
                if (blacklistActive && blacklist.size > 0) {
                    sitesToShow = sitesToShow.filter(site => !blacklist.has(site.id));
                }

                // If hideAlreadyPurchased is active, filter out already purchased sites
                if (hideAlreadyPurchased) {
                    sitesToShow = sitesToShow.filter(site => {
                        const status = sitesStatus.get(site.id) || { hasLinks: false, hasArticles: false };
                        const alreadyPurchased = status.hasLinks || status.hasArticles;
                        return !alreadyPurchased; // Exclude already purchased sites
                    });
                }

                // If GEO filter is active, filter by GEO value
                if (selectedGeo) {
                    sitesToShow = sitesToShow.filter(site => (site.geo || 'EN') === selectedGeo);
                }

                // Update GEO filter dropdown with available values
                updateGeoFilterOptions();

                // Prepare filtered sites with their status
                // NEW LOGIC: Red = already purchased (link OR article), cannot buy again
                filteredSites = sitesToShow.map(site => {
                    const status = sitesStatus.get(site.id) || { hasLinks: false, hasArticles: false };
                    const siteType = site.site_type || 'wordpress';

                    // Check if this site already has ANY placement for this project
                    const alreadyPurchased = status.hasLinks || status.hasArticles;

                    // Check if site type is incompatible with selected content type
                    const incompatibleType = (siteType === 'static_php' && contentType === 'articles');

                    // Check if site disallows articles (new check for allow_articles flag)
                    const articlesDisabled = (contentType === 'articles' && site.allow_articles === false);

                    // Determine status class and badge
                    let statusClass, statusBadge, isDisabled, disableReason;

                    if (alreadyPurchased) {
                        // Site already has placement for this project - mark red and disable
                        statusClass = 'table-danger';
                        statusBadge = '<span class="badge bg-danger">Уже куплено</span>';
                        isDisabled = true;
                        disableReason = 'Уже куплено';
                    } else if (incompatibleType) {
                        // Static PHP site cannot have articles
                        statusClass = 'table-warning';
                        statusBadge = '<span class="badge bg-warning">Только ссылки</span>';
                        isDisabled = true;
                        disableReason = 'Статичные сайты поддерживают только ссылки';
                    } else if (articlesDisabled) {
                        // Site owner disabled article placements
                        statusClass = 'table-secondary';
                        statusBadge = '<span class="badge bg-secondary">Статьи отключены</span>';
                        isDisabled = true;
                        disableReason = 'Владелец сайта отключил размещение гест-постов';
                    } else {
                        // Site available for purchase
                        statusClass = '';
                        statusBadge = '<span class="badge bg-success">Доступно</span>';
                        isDisabled = false;
                        disableReason = '';
                    }

                    return { ...site, statusClass, statusBadge, isDisabled, disableReason, siteType };
                });

                // Reset assignments and round-robin index
                siteAssignments = {};
                nextContentIndex = 0;

                // Hide sticky action bar on project/type change
                const actionBar = document.getElementById('stickyActionBar');
                actionBar.classList.remove('show');
                document.body.classList.remove('sticky-bar-active');

                // Reset to first page and render
                currentPage = 1;
                renderSitesTable();

                // Show the table
                document.getElementById('sitesTableDiv').style.display = 'block';

            } catch (error) {
                console.error('Error loading sites for placement:', error);
                showNotification('Failed to load sites: ' + error.message, 'error');
            }
        }

        function renderSitesTable() {
            // Update active filters info
            updateActiveFiltersInfo();

            if (filteredSites.length === 0) {
                document.getElementById('sitesTableBody').innerHTML = `
                    <tr><td colspan="18" class="text-center text-warning">
                        No sites match current filters. Try clearing whitelist/blacklist.
                    </td></tr>
                `;
                return;
            }

            const contentType = selectedContentType;
            const availableContent = contentType === 'links' ? projectLinks : projectArticles;

            // Calculate pagination
            const totalSites = filteredSites.length;
            const totalPages = Math.ceil(totalSites / sitesPerPage);
            const startIndex = (currentPage - 1) * sitesPerPage;
            const endIndex = Math.min(startIndex + sitesPerPage, totalSites);
            const pageSites = filteredSites.slice(startIndex, endIndex);

            // Update sites count info
            document.getElementById('sitesCountInfo').textContent =
                `Showing ${startIndex + 1}-${endIndex} of ${totalSites} sites`;

            // Build dropdown options for available content with usage counters
            // FILTER OUT EXHAUSTED CONTENT - only show items with usage_count < usage_limit
            const contentOptions = availableContent
                .filter(item => {
                    const usageCount = item.usage_count || 0;
                    const usageLimit = item.usage_limit || (contentType === 'articles' ? 1 : 999);
                    return usageCount < usageLimit; // Only show available items
                })
                .map(item => {
                    const displayName = contentType === 'links'
                        ? escapeHtml(item.anchor_text)
                        : escapeHtml(item.title);
                    const usageCount = item.usage_count || 0;
                    const usageLimit = item.usage_limit || (contentType === 'articles' ? 1 : 999);
                    const counter = `${usageCount}/${usageLimit}`;

                    // Validate ID is integer to prevent XSS
                    const safeId = parseInt(item.id);
                    if (isNaN(safeId)) {
                        console.error('Invalid item ID:', item.id);
                        return '';
                    }

                    return `<option value="${safeId}">${displayName} (${escapeHtml(counter)})</option>`;
                }).join('');

            // Render table rows for current page
            const tbody = document.getElementById('sitesTableBody');
            tbody.innerHTML = pageSites.map(site => {
                const dropdownHtml = site.isDisabled
                    ? '-'
                    : `<select class="form-select form-select-sm content-dropdown" id="content_${site.id}" style="display: none;">
                           <option value="">Select ${contentType === 'links' ? 'link' : 'article'}...</option>
                           ${contentOptions}
                       </select>`;

                // Site type badge
                const siteType = site.siteType || 'wordpress';
                const siteTypeBadge = siteType === 'wordpress'
                    ? '<span class="badge bg-secondary ms-1"><i class="bi bi-wordpress"></i> WP</span>'
                    : '<span class="badge bg-success ms-1"><i class="bi bi-filetype-php"></i> PHP</span>';

                // Visibility badge
                const visibilityBadge = site.is_public
                    ? '<span class="badge bg-info ms-1"><i class="bi bi-globe"></i> Публичный</span>'
                    : '<span class="badge bg-secondary ms-1"><i class="bi bi-lock-fill"></i> Личный сайт</span>';

                // Disable reason tooltip
                const tooltipAttr = site.disableReason
                    ? `title="${escapeHtml(site.disableReason)}" data-bs-toggle="tooltip"`
                    : '';

                // Clean URL - remove https:// and trailing slash
                const cleanUrl = site.site_url.replace(/^https?:\/\//, '').replace(/\/$/, '');

                // DR value with color coding
                const drValue = site.dr || 0;
                const drClass = drValue >= 50 ? 'text-success fw-bold' : drValue >= 20 ? 'text-primary' : 'text-muted';

                // DA value with color coding
                const daValue = site.da || 0;
                const daClass = daValue >= 50 ? 'text-success fw-bold' : daValue >= 20 ? 'text-primary' : 'text-muted';

                // TF value with color coding (Majestic Trust Flow, 0-100)
                const tfValue = site.tf || 0;
                const tfClass = tfValue >= 50 ? 'text-success fw-bold' : tfValue >= 20 ? 'text-primary' : 'text-muted';

                // CF value with color coding (Majestic Citation Flow, 0-100)
                const cfValue = site.cf || 0;
                const cfClass = cfValue >= 50 ? 'text-success fw-bold' : cfValue >= 20 ? 'text-primary' : 'text-muted';

                // Ref Domains, RD Main, Norm values
                const refDomainsValue = site.ref_domains || 0;
                const rdMainValue = site.rd_main || 0;
                const normValue = site.norm || 0;

                // Keywords and Traffic values (Ahrefs)
                const keywordsValue = site.keywords || 0;
                const trafficValue = site.traffic || 0;

                // GEO value (country code, default EN)
                const geoValue = site.geo || 'EN';

                // Price based on content type (with user's discount)
                // SPECIAL: $0.10 for user's own sites
                const currentUser = getCurrentUser();
                const isOwnSite = site.user_id === currentUser?.id;
                const price = isOwnSite
                    ? 0.10
                    : parseFloat(contentType === 'links'
                        ? (userPricing?.link?.finalPrice || 25)
                        : (userPricing?.article?.finalPrice || 15));

                // Slot availability display (dynamic based on content type)
                let slotsDisplay = '';
                let slotsClass = 'text-muted';
                if (contentType === 'links') {
                    // Main X/Y - used/total on main page
                    const usedLinks = site.used_links || 0;
                    const maxLinks = site.max_links || 0;
                    slotsDisplay = `Main ${usedLinks}/${maxLinks}`;
                    // Color coding: green if < 50% used, yellow if 50-80%, red if > 80%
                    if (maxLinks > 0) {
                        const usagePercent = (usedLinks / maxLinks) * 100;
                        slotsClass = usagePercent < 50 ? 'text-success' : usagePercent < 80 ? 'text-warning' : 'text-danger';
                    }
                } else {
                    // Articles X/Y - bought/remaining
                    const usedArticles = site.used_articles || 0;
                    const maxArticles = site.max_articles || 0;
                    const remaining = maxArticles - usedArticles;
                    slotsDisplay = `Art ${usedArticles}/${remaining}`;
                    // Color coding based on remaining slots
                    if (maxArticles > 0) {
                        const usagePercent = (usedArticles / maxArticles) * 100;
                        slotsClass = usagePercent < 50 ? 'text-success' : usagePercent < 80 ? 'text-warning' : 'text-danger';
                    }
                }

                return `
                    <tr class="${site.statusClass}">
                        <td>
                            <input type="checkbox" class="site-checkbox"
                                   data-site-id="${site.id}"
                                   onchange="onSiteCheckboxChange(${site.id}, this.checked)"
                                   ${site.isDisabled ? 'disabled' : ''}
                                   ${tooltipAttr}>
                        </td>
                        <td>
                            ${escapeHtml(maskUrl(cleanUrl, drValue, daValue))}
                        </td>
                        <td id="assigned_${site.id}">${dropdownHtml}</td>
                        <td class="${drClass} text-center">${drValue}</td>
                        <td class="${daClass} text-center">${daValue}</td>
                        <td class="${tfClass} text-center">${tfValue}</td>
                        <td class="${cfClass} text-center">${cfValue}</td>
                        <td class="text-muted text-center">${refDomainsValue}</td>
                        <td class="text-muted text-center">${rdMainValue}</td>
                        <td class="text-muted text-center">${normValue}</td>
                        <td class="text-muted text-center">${keywordsValue}</td>
                        <td class="text-muted text-center">${trafficValue}</td>
                        <td class="text-muted text-center">${geoValue}</td>
                        <td class="text-center">${siteTypeBadge}</td>
                        <td class="${slotsClass} text-nowrap text-center"><small>${slotsDisplay}</small></td>
                        <td class="text-success fw-bold text-center">$${typeof price === 'number' ? price.toFixed(2) : price}</td>
                        <td class="text-center">${site.statusBadge}</td>
                        <td class="text-center">${visibilityBadge}</td>
                    </tr>
                `;
            }).join('');

            // Initialize Bootstrap tooltips for disabled sites
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });

            // Render pagination controls
            renderPagination(totalPages);
        }

        function renderPagination(totalPages) {
            const paginationDiv = document.getElementById('paginationControls');
            const bottomPaginationNav = document.getElementById('bottomPaginationNav');
            const bottomPaginationDiv = document.getElementById('bottomPaginationControls');

            if (totalPages <= 1) {
                paginationDiv.innerHTML = '';
                bottomPaginationNav.style.display = 'none';
                return;
            }

            // Show bottom pagination
            bottomPaginationNav.style.display = 'block';

            let paginationHTML = '<nav><ul class="pagination pagination-sm mb-0">';

            // Previous button
            paginationHTML += `
                <li class="page-item ${currentPage === 1 ? 'disabled' : ''}">
                    <a class="page-link" href="#" onclick="changePage(${currentPage - 1}); return false;">Previous</a>
                </li>
            `;

            // Page numbers (show max 5 pages around current)
            const maxVisible = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
            let endPage = Math.min(totalPages, startPage + maxVisible - 1);

            if (endPage - startPage < maxVisible - 1) {
                startPage = Math.max(1, endPage - maxVisible + 1);
            }

            if (startPage > 1) {
                paginationHTML += `<li class="page-item"><a class="page-link" href="#" onclick="changePage(1); return false;">1</a></li>`;
                if (startPage > 2) {
                    paginationHTML += `<li class="page-item disabled"><span class="page-link">...</span></li>`;
                }
            }

            for (let i = startPage; i <= endPage; i++) {
                paginationHTML += `
                    <li class="page-item ${i === currentPage ? 'active' : ''}">
                        <a class="page-link" href="#" onclick="changePage(${i}); return false;">${i}</a>
                    </li>
                `;
            }

            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    paginationHTML += `<li class="page-item disabled"><span class="page-link">...</span></li>`;
                }
                paginationHTML += `<li class="page-item"><a class="page-link" href="#" onclick="changePage(${totalPages}); return false;">${totalPages}</a></li>`;
            }

            // Next button
            paginationHTML += `
                <li class="page-item ${currentPage === totalPages ? 'disabled' : ''}">
                    <a class="page-link" href="#" onclick="changePage(${currentPage + 1}); return false;">Next</a>
                </li>
            `;

            paginationHTML += '</ul></nav>';

            // Set both paginations to the same HTML
            paginationDiv.innerHTML = paginationHTML;
            bottomPaginationDiv.innerHTML = paginationHTML.replace('<nav><ul class="pagination pagination-sm mb-0">', '<ul class="pagination pagination-sm mb-0">').replace('</ul></nav>', '</ul>');
        }

        function changePage(page) {
            if (page < 1 || page > Math.ceil(filteredSites.length / sitesPerPage)) {
                return;
            }
            currentPage = page;
            renderSitesTable();
        }

        function onSiteCheckboxChange(siteId, isChecked) {
            const dropdown = document.getElementById(`content_${siteId}`);

            if (isChecked) {
                // Track selected site for list operations
                selectedSitesForList.add(siteId);

                // Show dropdown
                dropdown.style.display = 'block';

                // Auto-select next available content using round-robin
                const allContent = selectedContentType === 'links' ? projectLinks : projectArticles;

                // FILTER OUT EXHAUSTED CONTENT before round-robin selection
                const availableContent = allContent.filter(item => {
                    const usageCount = item.usage_count || 0;
                    const usageLimit = item.usage_limit || (selectedContentType === 'articles' ? 1 : 999);
                    return usageCount < usageLimit;
                });

                if (availableContent.length > 0) {
                    // Get next content using round-robin (cycle through available content)
                    const selectedContent = availableContent[nextContentIndex % availableContent.length];
                    nextContentIndex++;

                    // Set dropdown value
                    dropdown.value = selectedContent.id;

                    // Store assignment
                    const contentName = selectedContentType === 'links'
                        ? selectedContent.anchor_text
                        : selectedContent.title;

                    siteAssignments[siteId] = {
                        contentId: selectedContent.id,
                        contentName: contentName
                    };
                }

                // Add change listener to track manual selection changes
                dropdown.onchange = function() {
                    const contentId = parseInt(this.value);
                    if (contentId) {
                        const availableContent = selectedContentType === 'links' ? projectLinks : projectArticles;
                        const selectedContent = availableContent.find(c => c.id === contentId);

                        if (selectedContent) {
                            const contentName = selectedContentType === 'links'
                                ? selectedContent.anchor_text
                                : selectedContent.title;

                            siteAssignments[siteId] = {
                                contentId: contentId,
                                contentName: contentName
                            };
                        }
                    } else {
                        delete siteAssignments[siteId];
                    }

                    // Update create button state
                    updateCreateButtonState();
                };
            } else {
                // Remove from selected sites for list operations
                selectedSitesForList.delete(siteId);

                // Hide dropdown and remove assignment
                dropdown.style.display = 'none';
                dropdown.value = '';
                delete siteAssignments[siteId];
            }

            // Update create button state and list button counts
            updateCreateButtonState();
            updateListButtonCounts();

            // Update distribution preview if distributed mode is active
            if (document.getElementById('publishDistributed').checked) {
                updateDistributionPreview();
            }
        }

        function updateCreateButtonState() {
            // Enable button only if all checked sites have content selected
            const checkedSites = document.querySelectorAll('.site-checkbox:checked');
            let allHaveContent = checkedSites.length > 0;

            checkedSites.forEach(checkbox => {
                const siteId = parseInt(checkbox.dataset.siteId);
                if (!siteAssignments[siteId]) {
                    allHaveContent = false;
                }
            });

            // Update sticky action bar
            const selectedCount = checkedSites.length;
            const actionBar = document.getElementById('stickyActionBar');
            const purchaseBtn = document.getElementById('stickyPurchaseBtn');
            const whitelistBtn = document.getElementById('stickyWhitelistBtn');
            const blacklistBtn = document.getElementById('stickyBlacklistBtn');
            const purchaseBadge = document.getElementById('purchaseBadge');
            const whitelistBadge = document.getElementById('whitelistBadge');
            const blacklistBadge = document.getElementById('blacklistBadge');

            // Get bottom purchase button elements
            const bottomPurchaseDiv = document.getElementById('bottomPurchaseDiv');
            const bottomPurchaseBtn = document.getElementById('bottomPurchaseBtn');
            const bottomPurchaseBadge = document.getElementById('bottomPurchaseBadge');

            // Get total price badges
            const purchaseTotalBadge = document.getElementById('purchaseTotalBadge');
            const bottomPurchaseTotalBadge = document.getElementById('bottomPurchaseTotalBadge');

            if (selectedCount > 0) {
                // Show sticky bar and add body padding
                actionBar.classList.add('show');
                document.body.classList.add('sticky-bar-active');

                // Show bottom purchase button
                bottomPurchaseDiv.style.display = 'block';

                // Calculate total price - check each site's ownership for pricing
                const currentUser = getCurrentUser();
                const standardPrice = parseFloat(selectedContentType === 'links'
                    ? (userPricing?.link?.finalPrice || 25)
                    : (userPricing?.article?.finalPrice || 15));

                let totalPrice = 0;
                Object.keys(siteAssignments).forEach(siteIdStr => {
                    const siteId = parseInt(siteIdStr);
                    const site = sites.find(s => s.id === siteId);
                    if (site) {
                        // $0.10 for own sites, standard price for others
                        const isOwnSite = site.user_id === currentUser?.id;
                        totalPrice += isOwnSite ? 0.10 : standardPrice;
                    }
                });

                // Update all badges
                purchaseBadge.textContent = selectedCount;
                whitelistBadge.textContent = selectedCount;
                blacklistBadge.textContent = selectedCount;
                bottomPurchaseBadge.textContent = selectedCount;

                // Update total price badges - с 2 десятичными знаками
                purchaseTotalBadge.textContent = `$${totalPrice.toFixed(2)}`;
                bottomPurchaseTotalBadge.textContent = `$${totalPrice.toFixed(2)}`;

                // Enable/disable buttons based on content assignment AND project content availability
                const isEnabled = allHaveContent && hasAvailableContent;
                purchaseBtn.disabled = !isEnabled;
                bottomPurchaseBtn.disabled = !isEnabled;
                whitelistBtn.disabled = false;
                blacklistBtn.disabled = false;
            } else {
                // Hide sticky bar and remove body padding
                actionBar.classList.remove('show');
                document.body.classList.remove('sticky-bar-active');

                // Hide bottom purchase button
                bottomPurchaseDiv.style.display = 'none';

                // Reset buttons
                purchaseBtn.disabled = true;
                bottomPurchaseBtn.disabled = true;
                whitelistBtn.disabled = true;
                blacklistBtn.disabled = true;

                // Reset total price badges
                purchaseTotalBadge.textContent = '$0.00';
                bottomPurchaseTotalBadge.textContent = '$0.00';
            }
        }

        function updateListButtonCounts() {
            const count = selectedSitesForList.size;
            document.getElementById('whitelistCount').textContent = count;
            document.getElementById('blacklistCount').textContent = count;

            const addToWhitelistBtn = document.getElementById('addToWhitelistBtn');
            const addToBlacklistBtn = document.getElementById('addToBlacklistBtn');

            if (count > 0) {
                addToWhitelistBtn.disabled = false;
                addToBlacklistBtn.disabled = false;
                document.getElementById('listActionsDiv').style.display = 'block';
            } else {
                addToWhitelistBtn.disabled = true;
                addToBlacklistBtn.disabled = true;
            }
        }

        function toggleAllSites() {
            const selectAll = document.getElementById('selectAllSites').checked;
            const checkboxes = document.querySelectorAll('.site-checkbox:not(:disabled)');

            checkboxes.forEach(cb => {
                if (cb.checked !== selectAll) {
                    cb.checked = selectAll;
                    onSiteCheckboxChange(parseInt(cb.dataset.siteId), selectAll);
                }
            });
        }

        async function createPlacement() {
            const projectId = parseInt(document.getElementById('projectSelect').value);
            if (!projectId) {
                showNotification('Please select a project', 'error');
                return;
            }

            if (!selectedContentType) {
                showNotification('Please select content type (Links or Articles)', 'error');
                return;
            }

            // Check if project has content
            const availableContent = selectedContentType === 'links' ? projectLinks : projectArticles;
            if (availableContent.length === 0) {
                showNotification(`У проекта нет ${selectedContentType === 'links' ? 'ссылок' : 'гест-постов'}. Добавьте контент в проекте сначала.`, 'error');
                return;
            }

            if (Object.keys(siteAssignments).length === 0) {
                showNotification('Please select at least one site', 'error');
                return;
            }

            console.log('Creating placement with assignments:', siteAssignments);

            // Extract and validate scheduled publication date
            const publishType = document.querySelector('input[name="publishType"]:checked').value;
            let distributedDates = [];

            if (publishType === 'distributed') {
                const periodDays = parseInt(document.getElementById('distributionPeriod').value);
                const totalSites = Object.keys(siteAssignments).length;

                // Validate period (already in days, max 90)
                if (periodDays > 90) {
                    showNotification('Период распределения не может превышать 90 дней', 'error');
                    return;
                }

                // Calculate distributed dates
                distributedDates = calculateDistributedDates(totalSites, periodDays);
                console.log(`📅 Distributed ${totalSites} sites over ${periodDays} days:`, distributedDates);
            }

            // Build placement purchases with specific assignments
            const purchases = [];
            let dateIndex = 0;
            for (const [siteId, assignment] of Object.entries(siteAssignments)) {
                const purchaseData = {
                    projectId: projectId,
                    siteId: parseInt(siteId),
                    type: selectedContentType === 'links' ? 'link' : 'article',
                    contentIds: [assignment.contentId]
                };

                // Add scheduled date for distributed publication
                if (publishType === 'distributed' && distributedDates.length > 0) {
                    purchaseData.scheduledDate = distributedDates[dateIndex++];
                }

                purchases.push(purchaseData);
            }

            try {
                // Show progress modal for batch processing
                const totalPurchases = purchases.length;
                showPurchaseProgressModal(totalPurchases);

                console.log(`⚡ Starting batch purchase: ${totalPurchases} placements via single API call...`);
                const startTime = performance.now();

                // Use new batch endpoint - all purchases processed in parallel on server
                // This is 5-10x faster than individual requests
                const result = await BillingAPI.batchPurchase(purchases);

                const successful = result.data?.successful || 0;
                const failed = result.data?.failed || 0;
                const errors = (result.data?.errors || []).map(e => ({
                    site_id: e.siteId,
                    error: e.error
                }));

                // Update progress to 100%
                updatePurchaseProgress(100, successful, failed, totalPurchases, null);

                const endTime = performance.now();
                const serverDuration = result.data?.durationMs || 0;
                console.log(`✅ Completed in ${((endTime - startTime) / 1000).toFixed(2)}s (server: ${serverDuration}ms)`);

                // Complete progress modal
                completePurchaseProgress(successful, failed, errors);

                // Log detailed errors to console
                if (errors.length > 0) {
                    const errorDetails = errors.map(e => {
                        const site = filteredSites.find(s => s.id === e.site_id);
                        const siteName = site ? site.site_name : `ID ${e.site_id}`;
                        return `• ${siteName}: ${e.error}`;
                    }).join('\n');

                    console.error('=== ОШИБКИ РАЗМЕЩЕНИЙ ===');
                    console.error(errorDetails);
                    console.error('========================');
                }

                // Clear site selections but keep project and content type selected
                siteAssignments = {};
                nextContentIndex = 0;

                // Uncheck all site checkboxes
                document.querySelectorAll('.site-checkbox:checked').forEach(cb => {
                    cb.checked = false;
                });

                // Clear content dropdowns
                document.querySelectorAll('.content-select').forEach(select => {
                    select.style.display = 'none';
                });

                // Reload sites table to show updated availability (purchased sites marked as unavailable)
                const projectId = document.getElementById('projectSelect').value;
                if (projectId && selectedContentType) {
                    await loadSitesForPlacement(projectId, selectedContentType);
                }
            } catch (error) {
                // Critical error (not purchase failure, but system error)
                console.error('Critical error in createPlacements:', error);
                progressModal.hide();
                showNotification('Критическая ошибка при создании размещений: ' + error.message, 'error');
            }
        }

        // REMOVED: createPlacementAsync - Old batch async system no longer supported
        // Billing system processes purchases individually through BillingAPI.purchase

        function showProgressModal(job) {
            // Reset progress UI
            document.getElementById('progressStatus').textContent = 'Queued...';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressTotal').textContent = job.total_sites || 0;
            document.getElementById('progressSuccessful').textContent = '0';
            document.getElementById('progressFailed').textContent = '0';
            document.getElementById('progressResults').style.display = 'none';
            document.getElementById('progressErrors').style.display = 'none';
            document.getElementById('cancelJobBtn').style.display = 'block';
            document.getElementById('closeProgressBtn').style.display = 'none';

            progressModal.show();
        }

        function startJobPolling(jobId) {
            // Clear any existing poll
            if (pollInterval) {
                clearInterval(pollInterval);
            }

            // Poll every 2 seconds
            pollInterval = setInterval(async () => {
                await updateJobStatus(jobId);
            }, 2000);

            // Initial check
            updateJobStatus(jobId);
        }

        async function updateJobStatus(jobId) {
            try {
                const response = await fetch(`/api/placements/job/${jobId}`, {
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch job status');
                }

                const status = await response.json();

                // Update progress bar
                const percent = status.progress?.percent || 0;
                document.getElementById('progressPercent').textContent = `${Math.round(percent)}%`;
                document.getElementById('progressBar').style.width = `${percent}%`;

                // Update status text
                const stage = status.progress?.stage || status.status;
                document.getElementById('progressStatus').textContent = stage;

                // Update counts
                document.getElementById('progressTotal').textContent = status.total_sites || 0;
                document.getElementById('progressSuccessful').textContent = status.successful || 0;
                document.getElementById('progressFailed').textContent = status.failed || 0;

                // Handle completion
                if (status.status === 'completed' || status.status === 'failed') {
                    clearInterval(pollInterval);
                    pollInterval = null;

                    // Show results
                    if (status.results && status.results.length > 0) {
                        displayResults(status.results);
                    }

                    // Show errors
                    if (status.errors && status.errors.length > 0) {
                        displayErrors(status.errors);
                    }

                    // Update button
                    document.getElementById('cancelJobBtn').style.display = 'none';
                    document.getElementById('closeProgressBtn').style.display = 'block';

                    // Change progress bar color
                    const progressBar = document.getElementById('progressBar');
                    progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
                    if (status.status === 'completed') {
                        progressBar.classList.add('bg-success');
                        showNotification(`Batch placement completed: ${status.successful} successful, ${status.failed} failed`);
                    } else {
                        progressBar.classList.add('bg-danger');
                        showNotification('Batch placement failed', 'error');
                    }

                    // Just notify completion
                }
            } catch (error) {
                console.error('Error polling job status:', error);
            }
        }

        function displayResults(results) {
            const resultsList = document.getElementById('progressResultsList');
            resultsList.innerHTML = results.map(r => {
                const icon = r.success ? '✅' : '❌';
                const className = r.success ? 'text-success' : 'text-danger';
                return `
                    <div class="border-bottom pb-2 mb-2">
                        <span class="${className}">${icon}</span>
                        <strong>Site ID ${r.site_id}</strong>
                        ${r.site_name ? `(${escapeHtml(r.site_name)})` : ''}
                        - ${r.links_placed || 0} links, ${r.articles_placed || 0} articles
                    </div>
                `;
            }).join('');
            document.getElementById('progressResults').style.display = 'block';
        }

        function displayErrors(errors) {
            const errorsList = document.getElementById('progressErrorsList');
            errorsList.innerHTML = errors.map(e => `
                <li>Site ID ${e.site_id}: ${escapeHtml(e.error)}</li>
            `).join('');
            document.getElementById('progressErrors').style.display = 'block';
        }

        async function cancelCurrentJob() {
            if (!currentJobId) return;

            if (!confirm('Are you sure you want to cancel this job?')) return;

            try {
                const response = await fetch(`/api/placements/job/${currentJobId}/cancel`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${getAuthToken()}`
                    }
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to cancel job');
                }

                clearInterval(pollInterval);
                pollInterval = null;
                progressModal.hide();
                showNotification('Job cancelled successfully');
            } catch (error) {
                showNotification('Failed to cancel job: ' + error.message, 'error');
            }
        }

        function closeProgressModal() {
            clearInterval(pollInterval);
            pollInterval = null;
            currentJobId = null;
            progressModal.hide();
        }

        // === Purchase Progress Functions (Batch Processing) ===

        let purchaseCancelled = false; // Flag to cancel batch processing

        function showPurchaseProgressModal(total) {
            // Reset cancel flag
            purchaseCancelled = false;

            // Reset progress UI
            document.getElementById('progressStatus').textContent = 'Начинаем покупку...';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').classList.remove('bg-success', 'bg-danger');
            document.getElementById('progressBar').classList.add('progress-bar-animated', 'progress-bar-striped');
            document.getElementById('progressTotal').textContent = total;
            document.getElementById('progressSuccessful').textContent = '0';
            document.getElementById('progressFailed').textContent = '0';
            document.getElementById('progressResults').style.display = 'none';
            document.getElementById('progressErrors').style.display = 'none';
            document.getElementById('cancelJobBtn').style.display = 'block';
            document.getElementById('closeProgressBtn').style.display = 'none';

            // Update cancel button to cancel purchases
            document.getElementById('cancelJobBtn').onclick = () => {
                if (confirm('Отменить оставшиеся покупки?')) {
                    purchaseCancelled = true;
                    document.getElementById('progressStatus').textContent = 'Отменено пользователем...';
                }
            };

            progressModal.show();
        }

        function updatePurchaseProgress(percent, successful, failed, total, currentSiteName) {
            document.getElementById('progressPercent').textContent = `${percent}%`;
            document.getElementById('progressBar').style.width = `${percent}%`;
            document.getElementById('progressTotal').textContent = total;
            document.getElementById('progressSuccessful').textContent = successful;
            document.getElementById('progressFailed').textContent = failed;
            document.getElementById('progressStatus').textContent = currentSiteName
                ? `Обрабатываем: ${currentSiteName}...`
                : `Обработано ${successful + failed} из ${total}...`;
        }

        function completePurchaseProgress(successful, failed, errors) {
            const progressBar = document.getElementById('progressBar');
            progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');

            if (failed === 0) {
                progressBar.classList.add('bg-success');
                document.getElementById('progressStatus').textContent = 'Все покупки успешны!';
            } else if (successful === 0) {
                progressBar.classList.add('bg-danger');
                document.getElementById('progressStatus').textContent = 'Все покупки провалены';
            } else {
                progressBar.classList.add('bg-warning');
                document.getElementById('progressStatus').textContent = `Завершено: ${successful} успешно, ${failed} провалено`;
            }

            // Show errors if any
            if (errors && errors.length > 0) {
                displayErrors(errors);
            }

            // Switch buttons
            document.getElementById('cancelJobBtn').style.display = 'none';
            document.getElementById('closeProgressBtn').style.display = 'block';
        }

        // Whitelist/Blacklist Functions

        function loadListsFromStorage() {
            const storedWhitelist = localStorage.getItem('sitesWhitelist');
            const storedBlacklist = localStorage.getItem('sitesBlacklist');

            if (storedWhitelist) {
                whitelist = new Set(JSON.parse(storedWhitelist));
            }
            if (storedBlacklist) {
                blacklist = new Set(JSON.parse(storedBlacklist));
            }

            // Load but DON'T activate filters
            whitelistActive = false;
            blacklistActive = false;

            updateListTotals();
        }

        function saveListsToStorage() {
            localStorage.setItem('sitesWhitelist', JSON.stringify([...whitelist]));
            localStorage.setItem('sitesBlacklist', JSON.stringify([...blacklist]));
            updateListTotals();
        }

        function updateListTotals() {
            document.getElementById('whitelistTotal').textContent = whitelist.size;
            document.getElementById('blacklistTotal').textContent = blacklist.size;
        }

        function addSelectedToWhitelist() {
            // Get checked sites from placement checkboxes
            const checkedSites = document.querySelectorAll('.site-checkbox:checked');
            const siteIds = Array.from(checkedSites).map(cb => parseInt(cb.dataset.siteId));

            if (siteIds.length === 0) {
                showNotification('No sites selected', 'warning');
                return;
            }

            siteIds.forEach(siteId => {
                whitelist.add(siteId);
                blacklist.delete(siteId); // Remove from blacklist if exists
            });
            saveListsToStorage();
            showNotification(`Added ${siteIds.length} sites to whitelist`, 'success');
            renderWhitelistView();

            // Uncheck all sites and hide sticky bar
            checkedSites.forEach(cb => cb.checked = false);
            updateCreateButtonState();

            // Refresh sites table to apply filter
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function addSelectedToBlacklist() {
            // Get checked sites from placement checkboxes
            const checkedSites = document.querySelectorAll('.site-checkbox:checked');
            const siteIds = Array.from(checkedSites).map(cb => parseInt(cb.dataset.siteId));

            if (siteIds.length === 0) {
                showNotification('No sites selected', 'warning');
                return;
            }

            siteIds.forEach(siteId => {
                blacklist.add(siteId);
                whitelist.delete(siteId); // Remove from whitelist if exists
            });
            saveListsToStorage();
            showNotification(`Added ${siteIds.length} sites to blacklist`, 'success');
            renderBlacklistView();

            // Uncheck all sites and hide sticky bar
            checkedSites.forEach(cb => cb.checked = false);
            updateCreateButtonState();

            // Refresh sites table to apply filter
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function importWhitelist() {
            currentImportTarget = 'whitelist';
            document.getElementById('importListModalTitle').textContent = 'Import Whitelist Domains';
            document.getElementById('importDomainsText').value = '';
            importListModal.show();
        }

        function importBlacklist() {
            currentImportTarget = 'blacklist';
            document.getElementById('importListModalTitle').textContent = 'Import Blacklist Domains';
            document.getElementById('importDomainsText').value = '';
            importListModal.show();
        }

        function processImportedDomains() {
            const text = document.getElementById('importDomainsText').value;
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);

            // Extract domains from URLs or use as-is
            const domains = lines.map(line => {
                try {
                    const url = new URL(line.startsWith('http') ? line : `https://${line}`);
                    return url.hostname;
                } catch {
                    return line.replace(/^https?:\/\//, '').replace(/\/$/, '');
                }
            });

            // Find matching sites in our system
            const matchedSiteIds = [];
            domains.forEach(domain => {
                const matchedSite = sites.find(site => {
                    const siteUrl = site.site_url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                    return siteUrl === domain || siteUrl.includes(domain) || domain.includes(siteUrl);
                });
                if (matchedSite) {
                    matchedSiteIds.push(matchedSite.id);
                }
            });

            if (matchedSiteIds.length === 0) {
                showNotification('No matching sites found in the system', 'error');
                return;
            }

            // Add to appropriate list
            if (currentImportTarget === 'whitelist') {
                matchedSiteIds.forEach(id => {
                    whitelist.add(id);
                    blacklist.delete(id);
                });
                renderWhitelistView();
            } else {
                matchedSiteIds.forEach(id => {
                    blacklist.add(id);
                    whitelist.delete(id);
                });
                renderBlacklistView();
            }

            saveListsToStorage();
            showNotification(`Imported ${matchedSiteIds.length} sites to ${currentImportTarget}`, 'success');
            importListModal.hide();

            // Refresh sites table to apply filter
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function toggleWhitelistView() {
            // Toggle filter activation (don't show/hide the list below)
            whitelistActive = !whitelistActive;

            // Update button text
            const btn = event.target.closest('button');
            if (whitelistActive) {
                btn.innerHTML = '<i class="bi bi-eye-slash"></i> Hide (' + whitelist.size + ')';
                btn.classList.remove('btn-outline-success');
                btn.classList.add('btn-success');
            } else {
                btn.innerHTML = '<i class="bi bi-eye"></i> Show (' + whitelist.size + ')';
                btn.classList.remove('btn-success');
                btn.classList.add('btn-outline-success');
            }

            // Refresh sites table
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function toggleBlacklistView() {
            // Toggle filter activation (don't show/hide the list below)
            blacklistActive = !blacklistActive;

            // Update button text
            const btn = event.target.closest('button');
            if (blacklistActive) {
                btn.innerHTML = '<i class="bi bi-eye-slash"></i> Hide (' + blacklist.size + ')';
                btn.classList.remove('btn-outline-danger');
                btn.classList.add('btn-danger');
            } else {
                btn.innerHTML = '<i class="bi bi-eye"></i> Show (' + blacklist.size + ')';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-outline-danger');
            }

            // Refresh sites table
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function renderWhitelistView() {
            const container = document.getElementById('whitelistItems');
            if (whitelist.size === 0) {
                container.innerHTML = '<p class="text-muted text-center p-3">No sites in whitelist</p>';
                return;
            }

            const whitelistSites = sites.filter(site => whitelist.has(site.id));
            container.innerHTML = whitelistSites.map(site => `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${escapeHtml(site.site_name)}</strong><br>
                        <small class="text-muted">${escapeHtml(site.site_url)}</small>
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeFromWhitelist(${site.id})">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function renderBlacklistView() {
            const container = document.getElementById('blacklistItems');
            if (blacklist.size === 0) {
                container.innerHTML = '<p class="text-muted text-center p-3">No sites in blacklist</p>';
                return;
            }

            const blacklistSites = sites.filter(site => blacklist.has(site.id));
            container.innerHTML = blacklistSites.map(site => `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${escapeHtml(site.site_name)}</strong><br>
                        <small class="text-muted">${escapeHtml(site.site_url)}</small>
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeFromBlacklist(${site.id})">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        function removeFromWhitelist(siteId) {
            whitelist.delete(siteId);
            saveListsToStorage();
            renderWhitelistView();
            showNotification('Removed from whitelist', 'success');

            // Refresh sites table to apply filter
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function removeFromBlacklist(siteId) {
            blacklist.delete(siteId);
            saveListsToStorage();
            renderBlacklistView();
            showNotification('Removed from blacklist', 'success');

            // Refresh sites table to apply filter
            const projectId = document.getElementById('projectSelect').value;
            if (projectId && selectedContentType) {
                loadSitesForPlacement(projectId, selectedContentType);
            }
        }

        function clearWhitelist() {
            if (whitelist.size === 0) {
                showNotification('Whitelist is already empty', 'info');
                return;
            }

            if (confirm(`Clear all ${whitelist.size} sites from whitelist?`)) {
                whitelist.clear();
                saveListsToStorage();
                renderWhitelistView();
                showNotification('Whitelist cleared', 'success');

                // Refresh sites table to apply filter
                const projectId = document.getElementById('projectSelect').value;
                if (projectId && selectedContentType) {
                    loadSitesForPlacement(projectId, selectedContentType);
                }
            }
        }

        function clearBlacklist() {
            if (blacklist.size === 0) {
                showNotification('Blacklist is already empty', 'info');
                return;
            }

            if (confirm(`Clear all ${blacklist.size} sites from blacklist?`)) {
                blacklist.clear();
                saveListsToStorage();
                renderBlacklistView();
                showNotification('Blacklist cleared', 'success');

                // Refresh sites table to apply filter
                const projectId = document.getElementById('projectSelect').value;
                if (projectId && selectedContentType) {
                    loadSitesForPlacement(projectId, selectedContentType);
                }
            }
        }

        function updateActiveFiltersInfo() {
            const infoSpan = document.getElementById('activeFiltersInfo');
            if (!infoSpan) return; // Element doesn't exist, skip update

            const filters = [];

            if (whitelistActive && whitelist.size > 0) {
                filters.push(`<span class="badge bg-success">Whitelist Active: ${whitelist.size} sites</span>`);
            }
            if (blacklistActive && blacklist.size > 0) {
                filters.push(`<span class="badge bg-danger">Blacklist Active: ${blacklist.size} sites</span>`);
            }

            if (filters.length > 0) {
                infoSpan.innerHTML = filters.join(' ');
            } else {
                infoSpan.innerHTML = '';
            }
        }

        /**
         * Calculate evenly distributed dates over a period
         * @param {number} totalSites - Number of sites to distribute
         * @param {number} periodDays - Period in days
         * @returns {Array<string>} Array of ISO date strings
         */
        function calculateDistributedDates(totalSites, periodDays) {
            const now = new Date();
            const daysBetween = periodDays / totalSites;

            const dates = [];
            for (let i = 0; i < totalSites; i++) {
                const date = new Date(now);
                // Start from day 1 (i+1) to ensure all dates are in the future
                // For 2 sites over 5 days: site 1 = day 2.5, site 2 = day 5
                date.setDate(date.getDate() + Math.round((i + 1) * daysBetween));
                dates.push(date.toISOString());
            }

            return dates;
        }

        /**
         * Update the distribution preview text
         */
        function updateDistributionPreview() {
            const selectedCount = selectedSitesForList.size;
            const periodDays = parseInt(document.getElementById('distributionPeriod').value);
            const previewDiv = document.getElementById('distributionPreview');
            const previewText = document.getElementById('distributionPreviewText');

            if (selectedCount === 0) {
                previewDiv.style.display = 'none';
                return;
            }

            const daysBetween = (periodDays / selectedCount).toFixed(1);

            previewText.textContent = `${selectedCount} ${selectedCount === 1 ? 'сайт' : selectedCount < 5 ? 'сайта' : 'сайтов'} / ${periodDays} ${periodDays === 1 ? 'день' : periodDays < 5 ? 'дня' : 'дней'} = публикация каждые ${daysBetween} ${daysBetween == 1 ? 'день' : 'дня/дней'}`;
            previewDiv.style.display = 'block';
        }

    </script>
</body>
</html>
